# Enterprise Architecture Design
CA1
Brendan Kelly
X00159345

This is the GitHub repository for my CA1 submission.


# Part 1

The async and sync directories contain code, Dockerfiles, and kubernetes manifests to deploy the applications. The asynchronous application is from Jelena's lab 3. The synchronous application is a modified version of that - where the security console directly calls the two door deployments, instead of using a pub/sub approach. The doors in this case randomly generate entries based on a randomised time parameter. 

The applications are hosted in Google Kubernetes Engine.

Asynchronous: 
[http://34.68.240.121:31080/](http://34.68.240.121:31080/)

Synchronous: 
[http://34.68.240.121:31081/](http://34.68.240.121:31081/)

These URLs are subject to change, but I don't anticipate that they will.

# Part 2

Part 2 is a fully automated response & recovery time measurement system, using bash scripts.

## 1. Response Times

The average_response_times.sh script contains the code to measure the average response times of both the async and sync applications, through HTTP GET calls (called through curl). The number of runs is passed in as a parameter. A JSON object is constructed and sent to a Google Cloud Functions instance that contains a python script to generate a bar chart of the respective measurements (provided by Jelena). 

Finally, a HTML report file is generated containing the measurements and the image created by the cloud function.

To run this script, from within the reporting directory: 

    ./average_response_times.sh NUMBER_OF_RUNS

Where NUMBER_OF_RUNS is the number of times you would like to measure the response time of each application.

## 2. Async variable response time
The async_variable_response_times.sh script contains the code to measure the average response time of the asynchronous application. This differs from part 1, in that the publish and subscribe intervals are modified each run. This is achieved by forcibly replacing containers in GKE with the new parameters, waiting for them to come up, and then measuring the time.

Once again, a JSON object is created, and this time a line graph is generated by the Google Cloud Function. This line chart consists of lines (publish intervals), X-axis values (subscribe intervals), and Y-axis values (number of seconds to respond). A report is also generated, much like the previous section.

To run this script, from within the reporting directory: 

    ./async_variable_response_times.sh NUMBER_OF_RUNS

Where NUMBER_OF_RUNS is the number of times you would like to measure the response time of the application.

To modify the intervals, change the publishIntervals() and subscribeIntervals() arrays within the script.

## 3. Average recovery time
The average_recovery_times.sh script contains the code to measure the average recovery time of each deployment/pod that together make up each application.

The script loops through each defined deployment, kills the associated pod, takes a time measurement, and waits for the pod to be recreated. When the pod comes back online, the value for when it declared itself as ready is parsed, and compared to the start time measurement. The resulting value is the recovery time. An average is created from the user-defined number of runs to do this for each deployment. 

Like the other two parts, a JSON object is created, a bar chart generated from Google Cloud Functions, and a HTML report is saved to disk.

To run this script, from within the reporting directory: 

    ./average_recovery_times.sh NUMBER_OF_RUNS

Where NUMBER_OF_RUNS is the number of times you would like to measure the recovery time of each deployment.

# Other

## Running all scripts
To run all scripts as one execution, from within the reporting directory: 

    ./run_all_tests.sh NUMBER_OF_RUNS

Where NUMBER_OF_RUNS is the number of times you would like to measure the recovery/response time of each deployment/application.

## Reporting
Reports are saved to the reporting/reports/ directory.